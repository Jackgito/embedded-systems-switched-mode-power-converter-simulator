Here is the optimized prompt designed to be copied and pasted into an AI coding tool. It is structured as a step-by-step implementation guide to ensure the AI builds the foundation before adding the complex math.

***

# Prompt: Step-by-Step Implementation of DC-DC Converter Simulator (STM32 Nucleo)

**Role:** Embedded Systems Engineer
**Hardware:** STM32 Nucleo (e.g., F401RE/L476RG)
**Language:** C (HAL Library)
**Constraints:**
* **Inputs:** 1 User Button (Interrupt-based), UART RX (Interrupt/DMA).
* **Outputs:** 1 User LED (PWM), UART TX.
* **Architecture:** Non-blocking "Super-Loop" with modular design.
* **Terminology:** Use "Converter Model" (not plant model).

**Task:**
Create a firmware simulation of a DC-DC converter controlled by a discrete PI controller. Follow these **four strict implementation steps** to build the code. Do not combine steps; ensure the logic for Step 1 works before proceeding to Step 4.

---

### Step 1: State Machine & Basic Interrupts
**Goal:** Establish the system heartbeat and state switching.
1.  Define a global `enum` for System States: `IDLE`, `CONFIGURATION`, `MODULATING`.
2.  Configure the **User Button** with an Interrupt (EXTI).
3.  Inside the ISR, set a flag/semaphore to request a state change.
4.  Inside the `main` while-loop:
    * Check the button flag.
    * If pressed, cycle the state: `IDLE` $\to$ `CONFIGURATION` $\to$ `MODULATING` $\to$ `IDLE`.
    * Print the new state name to **UART** immediately upon change.
    * *Note:* Implement simple software debouncing (e.g., ignore button presses for 200ms after a trigger).

### Step 2: UI Structure & Data Placeholders
**Goal:** Create the user interface and data structures.
1.  Create a `struct` to hold system data: `ReferenceVoltage`, `OutputVoltage`, `Kp`, `Ki`, and `DutyCycle`. Initialize with reasonable defaults.
2.  Implement a **Non-blocking UART Menu** in the main loop (running at ~5Hz, use a non-blocking timestamp check, `HAL_GetTick`):
    * **If IDLE:** Print "System Halted. Press Button to Config."
    * **If CONFIGURATION:** Print the current values of $K_p$ and $K_i$. Listen for UART characters (e.g., 'w'/'s' to increase/decrease $K_p$) to change these values.
    * **If MODULATING:** Print a status line: "Ref: [Val] | V_out: [0.00] | Duty: [0%]".
3.  Ensure UART transmission does not block the CPU for long periods.

### Step 3: PWM & Visualization
**Goal:** Connect the visual feedback (LED).
1.  Configure a Timer to generate **PWM** on the User LED pin.
2.  In the `main` loop, handle the **Modulating State**:
    * Create a mock simulation variable (e.g., a counter or sine wave) to simulate a changing duty cycle.
    * Update the LED PWM duty cycle (CCR register) based on this mock variable.
    * Visually confirm: The LED should pulse/change brightness in Modulating mode and turn OFF in Idle mode.

### Step 4: The Converter Model & PI Controller
**Goal:** Replace mock values with the actual physics and control math.
1.  **The Converter Model:**
    * Implement the discrete state-space equation: $x(k+1) = Ax(k) + Bu_{in}(k)$.
    * **State Vector ($x$):** Array of 6 floats (currents/voltages).
    * **Input ($u_{in}$):** The control signal calculated by the PI controller.
    * **Matrix A & B:** Use the standard discrete LCL filter model coefficients.
    * **Output ($y$):** $y = Cx$ (where C extracts the output voltage state).
2.  **The PI Controller:**
    * Implement: $Error = Reference - MeasuredOutput$.
    * Calculate $U_{in}$ using discrete PI formula with the configurable $K_p, K_i$.
    * Clamp the output to 0.0 - 1.0 (0% to 100% duty cycle).
3.  **Integration:**
    * Run this math loop at a fixed high frequency (simulate 50kHz logic, even if the loop runs slower in reality).
    * Feed the PI output to the LED PWM duty cycle.
    * Feed the Converter Model output ($y$) to the UART print function.

---

**Deliverable:**
Provide the complete, modular C code (main.c, structs.h) following this structure. Ensure variable protection (atomic access) where the Interrupt interacts with the Main loop.